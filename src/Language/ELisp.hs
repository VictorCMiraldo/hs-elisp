{-# LANGUAGE PatternSynonyms       #-}
{-# LANGUAGE KindSignatures        #-}
{-# LANGUAGE FlexibleInstances     #-}
{-# LANGUAGE TemplateHaskell       #-}
{-# LANGUAGE DataKinds             #-}
{-# LANGUAGE GADTs                 #-}
{-# LANGUAGE MultiParamTypeClasses #-}
module Language.ELisp where

data ELit
  = EL_Int    Integer
  | EL_Float  Double
  | EL_String String
  | EL_Char   Char
  deriving (Eq , Show)

data ESExp
  -- Names and literals
  = ES_Name     String
  | ES_Lit      ELit
  -- Vectors and lists
  | ES_List     [ESExp]
  | ES_Vector   [ESExp]
  -- Quoting primitives
  | ES_Quote    ESExp
  | ES_BQuote   ESExp
  | ES_Comma    ESExp
  | ES_CommaAt  ESExp
  -- We'll lift defun to a constructor in the AST for easier control.
  -- Ideally, we'd like this constructor to have type:
  -- String -> [String] -> Maybe String -> [ESExp] -> ESExp
  -- But this breaks ghc on the code generated by mrsop! yay... lol
  | ES_Defun String [ESExp] String [ESExp]
  deriving (Eq , Show)
